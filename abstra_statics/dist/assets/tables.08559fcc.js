var j=Object.defineProperty;var w=(s,e,t)=>e in s?j(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t;var a=(s,e,t)=>(w(s,typeof e!="symbol"?e+"":e,t),t);import{k as n}from"./router.137cad81.js";import{E as b}from"./record.8ec4484a.js";import{a as h}from"./string.531d3676.js";import{Z as o}from"./jwt-decode.esm.45ad7f6d.js";(function(){try{var s=typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{},e=new Error().stack;e&&(s._sentryDebugIds=s._sentryDebugIds||{},s._sentryDebugIds[e]="85a7dc2b-c62f-4517-8793-8b8539b762eb",s._sentryDebugIdIdentifier="sentry-dbid-85a7dc2b-c62f-4517-8793-8b8539b762eb")}catch{}})();o.object({name:o.string().optional(),unique:o.boolean().optional(),nullable:o.boolean().optional(),type:o.object({newType:o.string(),using:o.string()}).optional(),default:o.string().optional(),foreignKey:o.object({columnId:o.string()}).nullish().optional()});const $={boolean:["boolean","bool"],int:["int","integer","int4"],varchar:["varchar","character varying"],json:["json"],jsonb:["jsonb"],date:["date"],timestamp:["timestamp","timestamp with time zone","timestamptz"],uuid:["uuid"],real:["real","float4","float8","double precision"],numeric:["numeric","decimal"],text:["text"],bigint:["bigint","int8"],smallint:["smallint","int2"]},T=s=>{for(const e of C)if($[e].includes(s))return e;throw new Error(`Unknown type: ${s}`)};class D{async create(e){return n.post(`projects/${e.projectId}/tables/${e.tableId}/columns`,e)}async delete(e){return n.delete(`projects/${e.projectId}/tables/${e.tableId}/columns/${e.id}`)}async update(e,t){return n.patch(`projects/${e.projectId}/tables/${e.tableId}/columns/${e.id}`,t)}async getById(e){return n.get(`projects/${e.projectId}/columns/${e.id}`)}}const g=new D,p=class{constructor(e){a(this,"record");this.record=b.from(e)}static async create(e,t,r,d,l,y,f,I){const m=await g.create({name:e,type:t,default:r,nullable:d,unique:l,tableId:y,projectId:f,foreignKey:I});return"error"in m?m:new p(m)}async update(e){const t={...this.record.changes,type:this.record.changes.type&&e?{newType:this.record.changes.type,using:e}:void 0};return Object.keys(t).length===0||!this.id?{success:!0,error:""}:(await g.update({id:this.id,tableId:this.tableId,projectId:this.projectId},t),{success:!0,error:""})}toDTO(){return this.record.state}get id(){return this.record.get("id")}get tableId(){return this.record.get("tableId")}get projectId(){return this.record.get("projectId")}get protected(){return this.record.get("protected")}get type(){return T(this.record.get("type"))}set type(e){this.record.set("type",e)}get name(){return this.record.get("name")}set name(e){this.record.set("name",e)}get nullable(){return this.record.get("nullable")}set nullable(e){this.record.set("nullable",e)}get unique(){return this.record.get("unique")}set unique(e){this.record.set("unique",e)}get primaryKey(){return this.record.get("primaryKey")}get default(){var e;return(e=this.record.get("default"))==null?void 0:e.split("::")[0]}set default(e){this.record.set("default",e)}get foreignKey(){return this.record.get("foreignKey")}set foreignKey(e){this.record.set("foreignKey",e)}async delete(){this.id&&await g.delete({id:this.id,tableId:this.tableId,projectId:this.projectId})}};let c=p;a(c,"fromDTO",e=>new p(e)),a(c,"fromID",async(e,t)=>{const r=await g.getById({projectId:e,id:t});return p.fromDTO(r.column)});const C=["varchar","int","boolean","json","jsonb","date","timestamp","uuid","real","numeric","text","bigint","smallint"],B={varchar:"'DEFAULT_VALUE'",int:"",boolean:"false",json:"'{}'::json",jsonb:"'{}'::jsonb",date:"now()",timestamp:"now()",uuid:"gen_random_uuid()",real:"0.0",numeric:"0",text:"'DEFAULT_VALUE'",bigint:"0",smallint:"0"};class R{async list(e){return n.get(`projects/${e}/tables`)}async create(e,t){return await n.post(`projects/${e.projectId}/tables`,t)}async get(e){return n.get(`projects/${e.projectId}/tables/${e.tableId}`)}async delete(e){return n.delete(`projects/${e.projectId}/tables/${e.tableId}`)}async selectRows(e){return n.get(`projects/${e.projectId}/tables/${e.tableId}/rows`,{limit:e.limit.toString(),offset:e.offset.toString(),search:e.search,where:JSON.stringify(e.where),orderBy:JSON.stringify(e.orderBy)})}async update(e,t){return n.patch(`projects/${e.projectId}/tables/${e.tableId}`,t)}async insertRow(e,t){return n.post(`projects/${e.projectId}/tables/${e.tableId}/rows`,t)}async updateRow(e,t){return n.patch(`projects/${e.projectId}/tables/${e.tableId}/rows/${e.rowId}`,t)}async deleteRow(e){return n.delete(`projects/${e.projectId}/tables/${e.tableId}/rows/${e.rowId}`)}async getByColumnID(e){return n.get(`projects/${e.projectId}/columns/${e.columnId}`)}}const i=new R;class u{constructor(e,t){a(this,"record");a(this,"columns");this.projectId=e,this.record=b.from(t),this.columns=t.columns.map(r=>c.fromDTO({...r,projectId:t.projectId}))}static async list(e){return(await i.list(e)).map(r=>new u(e,r))}static async fromColumnId(e,t){const r=await i.getByColumnID({projectId:e,columnId:t});return u.get(e,r.table.id)}static async create(e,t,r){const d=h(t,!1),l=await i.create({projectId:e},{name:d,id:r});return new u(e,l)}static async get(e,t){const r=await i.get({projectId:e,tableId:t});return new u(e,{...r.table,columns:r.columns})}async delete(e,t){return i.delete({projectId:e,tableId:t})}fixTraillingName(){this.name=h(this.name,!1)}async save(){if(Object.keys(this.record.changes).length!==0){this.record.changes.name&&this.fixTraillingName();try{await i.update({id:this.id,tableId:this.id,projectId:this.projectId},this.record.changes)}finally{this.record.resetChanges()}}}resetChanges(){this.record.resetChanges()}onUpdate(e){this.record.pubsub.subscribe("update",e)}hasChanges(){return this.record.hasChanges()}hasChangesDeep(e){return this.record.hasChangesDeep(e)&&h(this.name,!1)!==this.record.initialState.name}getColumns(){var e;return(e=this.columns)!=null?e:[]}getUnprotectedColumns(){var e,t;return(t=(e=this.columns)==null?void 0:e.filter(r=>!r.protected).map(r=>r.toDTO()))!=null?t:[]}get id(){return this.record.get("id")}get name(){return this.record.get("name")}set name(e){const t=h(e,!0);this.record.set("name",t)}async addColumn(e){const t=await c.create(e.name,e.type,e.default,e.nullable,e.unique,this.id,this.projectId,e.foreignKey);return"error"in t?{success:!1,error:t.error}:this.columns?(this.columns.push(t),{success:!0,error:""}):(this.columns=[t],{success:!0,error:""})}getColumn(e){var t;return(t=this.columns)==null?void 0:t.find(r=>r.id&&r.id===e)}async select(e={},t,r,d,l){return i.selectRows({name:this.name,where:e,tableId:this.id,projectId:this.projectId,limit:r,offset:t,search:d,orderBy:l})}async insertRow(e){return i.insertRow({tableId:this.id,projectId:this.projectId},e)}async updateRow(e,t){return i.updateRow({tableId:this.id,projectId:this.projectId,rowId:e},t)}async deleteRow(e){return i.deleteRow({tableId:this.id,projectId:this.projectId,rowId:e})}}export{c as C,u as T,B as d,C as p};
//# sourceMappingURL=tables.08559fcc.js.map
