var c=Object.defineProperty;var i=(a,t,e)=>t in a?c(a,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):a[t]=e;var d=(a,t,e)=>(i(a,typeof t!="symbol"?t+"":t,e),e);import{k as r}from"./router.f720aa78.js";import"./jwt-decode.esm.abec95f0.js";(function(){try{var a=typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{},t=new Error().stack;t&&(a._sentryDebugIds=a._sentryDebugIds||{},a._sentryDebugIds[t]="3390cbc9-7d28-456a-93f3-5e2923dbfe0a",a._sentryDebugIdIdentifier="sentry-dbid-3390cbc9-7d28-456a-93f3-5e2923dbfe0a")}catch{}})();class y{async createTask(t,e,s){return fetch("/_editor/api/tasks",{method:"POST",body:JSON.stringify({name:t,payload:s,stage_id:e}),headers:{"Content-Type":"application/json"}}).then(n=>n.json())}async getAllTasks(t,e){const s={offset:t.currentIndex*t.pageSize,limit:t.pageSize,filter:{stage:e.stage,status:e.status,startDate:e.dateRange?e.dateRange[0]:void 0,endDate:e.dateRange?e.dateRange[1]:void 0}};return fetch("/_editor/api/tasks/list",{method:"POST",body:JSON.stringify(s),headers:{"Content-Type":"application/json"}}).then(n=>n.json())}async getStageTasks(t){return fetch(`/_editor/api/tasks/${t}`).then(e=>e.json())}async getSentStageTasks(t){return fetch(`/_editor/api/tasks/${t}/sent`).then(e=>e.json())}async updateTaskStatus(t,e){return fetch(`/_editor/api/tasks/${t}/status`,{method:"PUT",body:JSON.stringify({status:e}),headers:{"Content-Type":"application/json"}}).then(s=>s.json())}async clearAllTasks(){return fetch("/_editor/api/tasks/clear",{method:"DELETE"}).then(t=>t.json())}}class h{constructor(t){d(this,"projectId");this.projectId=t}async createTask(t,e,s){return await r.post(`projects/${this.projectId}/tasks`,{name:t,stageId:e,payload:s})}async getAllTasks(t,e){const s={offset:(t.currentIndex*t.pageSize).toString(),limit:t.pageSize.toString(),stageId:e.stage,status:e.status,startDate:e.dateRange?e.dateRange[0]:void 0,endDate:e.dateRange?e.dateRange[1]:void 0};return Object.keys(s).forEach(o=>s[o]===void 0&&delete s[o]),await r.get(`projects/${this.projectId}/tasks`,s)}async getTasksStatistics(){return await r.get(`projects/${this.projectId}/tasks/statistics`)}async getStageTasks(t){const e={stageId:t,offset:"0",limit:"1000"};return await r.get(`projects/${this.projectId}/tasks`,e)}async getSentStageTasks(t){const e={sourceStageId:t,offset:"0",limit:"1000"};return await r.get(`projects/${this.projectId}/tasks`,e)}async updateTaskStatus(t,e){throw new Error("Method not implemented.")}async fetchStages(){throw new Error("Method not implemented.")}async fetchStatuses(){throw new Error("Method not implemented.")}async clearAllTasks(){throw new Error("Method not implemented.")}}export{y as L,h as R};
//# sourceMappingURL=repository.c57c5855.js.map
