var D=Object.defineProperty;var M=(n,t,a)=>t in n?D(n,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):n[t]=a;var T=(n,t,a)=>(M(n,typeof t!="symbol"?t+"":t,a),a);import{C as h}from"./gateway.22c5659c.js";import{e as k,f as _,ep as R,E as O,g as J}from"./index.9cc3d5c7.js";import"./linters.bf5c3266.js";import{F as z,H as N,J as $,S as q}from"./scripts.b63dbabe.js";import{u as F}from"./polling.36f8aa1b.js";import{c as L}from"./string.22f3398b.js";(function(){try{var n=typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{},t=new Error().stack;t&&(n._sentryDebugIds=n._sentryDebugIds||{},n._sentryDebugIds[t]="43e08193-3e82-4ad4-8255-0d0d458d9b8e",n._sentryDebugIdIdentifier="sentry-dbid-43e08193-3e82-4ad4-8255-0d0d458d9b8e")}catch{}})();class Y{async createTask(t,a,r){return fetch("/_editor/api/tasks",{method:"POST",body:JSON.stringify({name:t,payload:r,stage_id:a}),headers:{"Content-Type":"application/json"}}).then(o=>o.json())}async getAllTasks(t,a){const r={offset:t.currentIndex*t.pageSize,limit:t.pageSize,filter:{stage:a.stage,status:a.status,startDate:a.dateRange?a.dateRange[0]:void 0,endDate:a.dateRange?a.dateRange[1]:void 0}};return fetch("/_editor/api/tasks/list",{method:"POST",body:JSON.stringify(r),headers:{"Content-Type":"application/json"}}).then(o=>o.json())}async getStageTasks(t){return fetch(`/_editor/api/tasks/${t}`).then(a=>a.json())}async getSentStageTasks(t){return fetch(`/_editor/api/tasks/${t}/sent`).then(a=>a.json())}async updateTaskStatus(t,a){return fetch(`/_editor/api/tasks/${t}/status`,{method:"PUT",body:JSON.stringify({status:a}),headers:{"Content-Type":"application/json"}}).then(r=>r.json())}async clearAllTasks(){return fetch("/_editor/api/tasks/clear",{method:"DELETE"}).then(t=>t.json())}}class Z{constructor(t){T(this,"projectId");this.projectId=t}async createTask(t,a,r){return await h.post(`projects/${this.projectId}/tasks`,{name:t,stageId:a,payload:r})}async getAllTasks(t,a){const r={offset:(t.currentIndex*t.pageSize).toString(),limit:t.pageSize.toString(),stageId:a.stage,status:a.status,startDate:a.dateRange?a.dateRange[0]:void 0,endDate:a.dateRange?a.dateRange[1]:void 0};return Object.keys(r).forEach(g=>r[g]===void 0&&delete r[g]),await h.get(`projects/${this.projectId}/tasks`,r)}async getStageTasks(t){throw new Error("Method not implemented.")}async getSentStageTasks(t){throw new Error("Method not implemented.")}async updateTaskStatus(t,a){throw new Error("Method not implemented.")}async fetchStages(){throw new Error("Method not implemented.")}async fetchStatuses(){throw new Error("Method not implemented.")}async clearAllTasks(){throw new Error("Method not implemented.")}}function H({api:n,stageId:t,fetchTasks:a}){const r=k({state:"idle"}),o=()=>{r.value={state:"idle"}},g=()=>{r.value={state:"creating",name:"My task",payloadCode:`{
  "key": "value"
}`}},y=async()=>{if(!t)throw new Error("StageId is required to create a task");const l=r.value;if(l.state!=="creating")throw new Error("Payload is required to create a task");if(!d.value)return;const i=JSON.parse(l.payloadCode);n.createTask(l.name,t,i).then(a).then(o)},d=_(()=>{const l=r.value;if(l.state!=="creating")return!1;try{const i=JSON.parse(l.payloadCode);return R.exports.isObject(i)}catch{return!1}});return{createTask:y,creatingTaskState:r,cancelCreatingTask:o,startCreatingTask:g,isPayloadValid:d}}const f=["pink","orange","green","blue","purple","red","cyan","magenta","volcano","gold"],ee=({api:n,poll:t,stageId:a,stages:r})=>{const o=O({tasks:[],sentTasks:[],colorMap:new Map,pagination:{currentIndex:0,pageSize:10,totalCount:0},filters:{stage:void 0,status:void 0,dateRange:void 0},filterOptions:{stages:[],statuses:["pending","started","completed"].map(s=>({label:L(s),value:s}))}}),g=[{name:"setToPending",label:"Set to pending",handler:()=>{o.tasks.filter(e=>e.checked).map(e=>e.id).forEach(e=>S(e))}},{name:"setToCompleted",label:"Set to completed",handler:()=>{o.tasks.filter(e=>e.checked).map(e=>e.id).forEach(e=>m(e))}},{name:"duplicate",label:"Duplicate",handler:()=>{o.tasks.filter(e=>e.checked).forEach(async e=>{await n.createTask(e.type,e.targetStageId,e.payload),d()})}}],y=k(["pending"]),d=async()=>{const s=a?await n.getStageTasks(a):await n.getAllTasks(o.pagination,o.filters);o.tasks=s.tasks.map(e=>({key:e.id,id:e.id,type:e.type,status:e.status,targetStageId:e.targetStageId,targetStageTitle:e.targetStageTitle,targetStageType:e.targetStageType,sourceStageTitle:e.sourceStageTitle,sourceStageType:e.sourceStageType,created:{at:new Date(e.created.at).toString(),byExecutionId:e.created.byExecutionId,byStageId:e.created.byStageId},locked:e.locked?{at:new Date(e.locked.at).toString(),byExecutionId:e.locked.byExecutionId,byStageId:e.locked.byStageId}:null,completed:e.completed?{at:new Date(e.completed.at).toString(),byExecutionId:e.completed.byExecutionId,byStageId:e.completed.byStageId}:null,payload:e.payload,checked:!1})),o.pagination.totalCount=s.totalCount},l=async()=>{if(!a)return[];const s=await n.getSentStageTasks(a);o.sentTasks=s.tasks.map(e=>({key:e.id,id:e.id,type:e.type,status:e.status,targetStageId:e.targetStageId,targetStageTitle:e.targetStageTitle,targetStageType:e.targetStageType,sourceStageTitle:e.sourceStageTitle,sourceStageType:e.sourceStageType,created:{at:new Date(e.created.at).toString(),byExecutionId:e.created.byExecutionId,byStageId:e.created.byStageId},locked:e.locked?{at:new Date(e.locked.at).toString(),byExecutionId:e.locked.byExecutionId,byStageId:e.locked.byStageId}:null,completed:e.completed?{at:new Date(e.completed.at).toString(),byExecutionId:e.completed.byExecutionId,byStageId:e.completed.byStageId}:null,payload:e.payload}))},i=()=>{var p;let s=0;o.tasks.concat((p=o.sentTasks)!=null?p:[]).forEach(u=>{o.colorMap.has(u.type)||(o.colorMap.set(u.type,f[s]),s=(s+1)%f.length)})};J(o.filters,async()=>{await Promise.all([d(),l()]),i()});const I=async()=>{await Promise.all([d(),l()]),i()},{startPolling:b,endPolling:w}=F({task:I,interval:15e3}),E=async()=>{if(await Promise.all([d(),l()]),i(),r===null){const s=Promise.all([z.list(),N.list(),$.list(),q.list()]).then(([e,p,u,c])=>[...e,...p,...u,...c]);o.filterOptions.stages=(await s).map(e=>({label:e.title,value:e.id}))}else o.filterOptions.stages=r.map(s=>({label:s.stageTitle,value:s.id}));t&&b()},C=()=>{t&&w()},S=async s=>{await n.updateTaskStatus(s,"pending"),d()},m=async s=>{await n.updateTaskStatus(s,"completed"),d()},v=s=>{o.tasks=o.tasks.map(e=>(e.id===s&&(e.checked=!e.checked),e))},x=()=>{const s=[],e=o.tasks.filter(c=>c.checked);return e.length===0?[]:(s.push("duplicate"),e.every(c=>c.status==="pending")&&s.push("setToCompleted"),e.every(c=>c.status==="completed")&&s.push("setToPending"),g.filter(c=>s.includes(c.name)))},P=async()=>{await n.clearAllTasks(),d(),l()},j=()=>[{title:"Type",dataIndex:"type",key:"type",align:"center"},{title:"Payload",dataIndex:"payload",key:"payload",align:"center",width:"20%"},{title:"Status",dataIndex:"status",key:"status",align:"center",filterMode:"menu"},{title:"Stage",dataIndex:"targetStageTitle",key:"targetStageTitle",align:"center"},{title:"Created at",dataIndex:"createdAt",key:"createdAt",align:"center"},{title:"Completed at",dataIndex:"completedAt",key:"completedAt",align:"center"}],A=H({api:n,stageId:a,fetchTasks:d});return{setup:E,tearDown:C,state:o,getColumns:j,collapseValue:y,setToPending:S,setToCompleted:m,fetchTasks:d,fetchSentTasks:l,checkTask:v,getPossibleActions:x,clearAllTasks:P,...A}};export{Y as L,Z as R,ee as T};
//# sourceMappingURL=tasksController.44c6b0fb.js.map
